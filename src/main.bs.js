// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_list from "rescript/lib/es6/js_list.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Js_option from "rescript/lib/es6/js_option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

function xsOfBlock(b) {
  return Js_list.toVector(Js_list.flatten(Js_list.map((function (trm) {
                        if (trm.TAG === /* Def */0) {
                          return {
                                  hd: trm._0._0,
                                  tl: /* [] */0
                                };
                        } else {
                          return /* [] */0;
                        }
                      }), b[0])));
}

var stdout = {
  contents: /* [] */0
};

function print(v) {
  stdout.contents = {
    hd: /* Val */{
      _0: v
    },
    tl: stdout.contents
  };
}

function extend(env, xs) {
  return {
          hd: Js_array.map((function (x) {
                  return [
                          x,
                          {
                            contents: undefined
                          }
                        ];
                }), xs),
          tl: env
        };
}

var UnboundIdentifier = /* @__PURE__ */Caml_exceptions.create("Main.UnboundIdentifier");

function lookup(env, x) {
  if (env) {
    return Js_option.getWithDefault(lookup(env.tl, x), Js_option.map((function (param) {
                      return param[1];
                    }), Js_array.find((function (param) {
                          return x === param[0];
                        }), env.hd)));
  }
  throw {
        RE_EXN_ID: UnboundIdentifier,
        _1: x,
        Error: new Error()
      };
}

var UsedBeforeInitialization = /* @__PURE__ */Caml_exceptions.create("Main.UsedBeforeInitialization");

function doRef(env, x) {
  var v = lookup(env, x).contents;
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw {
        RE_EXN_ID: UsedBeforeInitialization,
        _1: x,
        Error: new Error()
      };
}

function doSet(env, x, v) {
  lookup(env, x).contents = Caml_option.some(v);
}

function consCtx(ctxFrame, stt) {
  return {
          ctx: {
            hd: ctxFrame,
            tl: stt.ctx
          },
          env: stt.env,
          stk: stt.stk
        };
}

function caseCtx(stt) {
  var match = stt.ctx;
  if (match) {
    return {
            TAG: /* Yes */0,
            _0: [
              match.hd,
              {
                ctx: match.tl,
                env: stt.env,
                stk: stt.stk
              }
            ]
          };
  } else {
    return {
            TAG: /* No */1,
            _0: stt.stk
          };
  }
}

function evaluate(exp) {
  return {
          TAG: /* Ev */1,
          _0: exp,
          _1: {
            ctx: /* [] */0,
            env: /* [] */0,
            stk: /* [] */0
          }
        };
}

var ExpectButGiven = /* @__PURE__ */Caml_exceptions.create("Main.ExpectButGiven");

function asNum(v) {
  if (typeof v === "number") {
    throw {
          RE_EXN_ID: ExpectButGiven,
          _1: "number",
          _2: v,
          Error: new Error()
        };
  }
  if (v.TAG === /* Con */0) {
    var v$1 = v._0;
    if (v$1.TAG === /* Num */0) {
      return v$1._0;
    }
    throw {
          RE_EXN_ID: ExpectButGiven,
          _1: "number",
          _2: v,
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: ExpectButGiven,
        _1: "number",
        _2: v,
        Error: new Error()
      };
}

function asLgc(v) {
  if (typeof v === "number") {
    throw {
          RE_EXN_ID: ExpectButGiven,
          _1: "boolean",
          _2: v,
          Error: new Error()
        };
  }
  if (v.TAG === /* Con */0) {
    var v$1 = v._0;
    if (v$1.TAG !== /* Num */0) {
      return v$1._0;
    }
    throw {
          RE_EXN_ID: ExpectButGiven,
          _1: "boolean",
          _2: v,
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: ExpectButGiven,
        _1: "boolean",
        _2: v,
        Error: new Error()
      };
}

function asFun(v) {
  if (typeof v === "number") {
    throw {
          RE_EXN_ID: ExpectButGiven,
          _1: "function",
          _2: v,
          Error: new Error()
        };
  }
  if (v.TAG !== /* Con */0) {
    return v._0;
  }
  throw {
        RE_EXN_ID: ExpectButGiven,
        _1: "function",
        _2: v,
        Error: new Error()
      };
}

function doAdd(u, v) {
  return {
          TAG: /* Con */0,
          _0: {
            TAG: /* Num */0,
            _0: asNum(u) + asNum(v)
          }
        };
}

function transitionBgn(param, stt) {
  var e = param[1];
  var ts = param[0];
  if (!ts) {
    return {
            TAG: /* Ev */1,
            _0: e,
            _1: stt
          };
  }
  var e0 = ts.hd;
  if (e0.TAG !== /* Def */0) {
    return {
            TAG: /* Ev */1,
            _0: e0._0,
            _1: consCtx({
                  TAG: /* BgnExp */5,
                  _0: undefined,
                  _1: [
                    ts.tl,
                    e
                  ]
                }, stt)
          };
  }
  var match = e0._0;
  return {
          TAG: /* Ev */1,
          _0: match._1,
          _1: consCtx({
                TAG: /* BgnDef */4,
                _0: match._0,
                _1: undefined,
                _2: [
                  ts.tl,
                  e
                ]
              }, stt)
        };
}

function transitionPrg(vs, ts, stt) {
  if (!ts) {
    return {
            TAG: /* Tm */0,
            _0: vs
          };
  }
  var e0 = ts.hd;
  if (e0.TAG !== /* Def */0) {
    return {
            TAG: /* Ev */1,
            _0: e0._0,
            _1: consCtx({
                  TAG: /* PrgExp */7,
                  _0: vs,
                  _1: undefined,
                  _2: ts.tl
                }, stt)
          };
  }
  var match = e0._0;
  return {
          TAG: /* Ev */1,
          _0: match._1,
          _1: consCtx({
                TAG: /* PrgDef */6,
                _0: vs,
                _1: match._0,
                _2: undefined,
                _3: ts.tl
              }, stt)
        };
}

function pushStk(env, stt) {
  return {
          ctx: /* [] */0,
          env: env,
          stk: {
            hd: [
              stt.ctx,
              stt.env
            ],
            tl: stt.stk
          }
        };
}

function doBlk(b, stt) {
  return transitionBgn(b, pushStk(extend(stt.env, xsOfBlock(b)), stt));
}

function deltaNum1(f, v, vs) {
  var v$1 = asNum(v);
  var vs$1 = Js_list.map(asNum, vs);
  return {
          TAG: /* Con */0,
          _0: {
            TAG: /* Num */0,
            _0: Js_list.foldLeft(f, v$1, vs$1)
          }
        };
}

function deltaNum2(f, v1, v2, vs) {
  var v1$1 = asNum(v1);
  var v2$1 = asNum(v2);
  var vs$1 = Js_list.map(asNum, vs);
  return {
          TAG: /* Con */0,
          _0: {
            TAG: /* Num */0,
            _0: Js_list.foldLeft(f, f(v1$1, v2$1), vs$1)
          }
        };
}

function deltaCmp(cmp, v, vs) {
  var v$1 = asNum(v);
  var vs$1 = Js_list.map(asNum, vs);
  var loop = function (_v1, _vs) {
    while(true) {
      var vs = _vs;
      var v1 = _v1;
      if (!vs) {
        return true;
      }
      var v2 = vs.hd;
      if (!Curry._2(cmp, v1, v2)) {
        return false;
      }
      _vs = vs.tl;
      _v1 = v2;
      continue ;
    };
  };
  return {
          TAG: /* Con */0,
          _0: {
            TAG: /* Lgc */1,
            _0: loop(v$1, vs$1)
          }
        };
}

function arityOf(p) {
  if (p !== 1 && p < 3) {
    return {
            TAG: /* AtLeast */0,
            _0: 1
          };
  } else {
    return {
            TAG: /* AtLeast */0,
            _0: 2
          };
  }
}

var ArityMismatch = /* @__PURE__ */Caml_exceptions.create("Main.ArityMismatch");

function delta(p, vs) {
  switch (p) {
    case /* Add */0 :
        if (vs) {
          return deltaNum1((function (a, b) {
                        return a + b;
                      }), vs.hd, vs.tl);
        }
        break;
    case /* Sub */1 :
        if (vs) {
          var match = vs.tl;
          if (match) {
            return deltaNum2((function (a, b) {
                          return a - b;
                        }), vs.hd, match.hd, match.tl);
          }
          
        }
        break;
    case /* Mul */2 :
        if (vs) {
          return deltaNum1((function (a, b) {
                        return a * b;
                      }), vs.hd, vs.tl);
        }
        break;
    case /* Div */3 :
        if (vs) {
          var match$1 = vs.tl;
          if (match$1) {
            return deltaNum2((function (a, b) {
                          return a / b;
                        }), vs.hd, match$1.hd, match$1.tl);
          }
          
        }
        break;
    case /* Lt */4 :
        if (vs) {
          return deltaCmp((function (a, b) {
                        return a < b;
                      }), vs.hd, vs.tl);
        }
        break;
    case /* Eq */5 :
        if (vs) {
          return deltaCmp((function (a, b) {
                        return a === b;
                      }), vs.hd, vs.tl);
        }
        break;
    case /* Gt */6 :
        if (vs) {
          return deltaCmp((function (a, b) {
                        return a > b;
                      }), vs.hd, vs.tl);
        }
        break;
    case /* Le */7 :
        if (vs) {
          return deltaCmp((function (a, b) {
                        return a <= b;
                      }), vs.hd, vs.tl);
        }
        break;
    case /* Ge */8 :
        if (vs) {
          return deltaCmp((function (a, b) {
                        return a >= b;
                      }), vs.hd, vs.tl);
        }
        break;
    case /* Ne */9 :
        if (vs) {
          return deltaCmp((function (a, b) {
                        return a !== b;
                      }), vs.hd, vs.tl);
        }
        break;
    
  }
  throw {
        RE_EXN_ID: ArityMismatch,
        _1: arityOf(p),
        _2: List.length(vs),
        Error: new Error()
      };
}

var Impossible = /* @__PURE__ */Caml_exceptions.create("Main.Impossible");

function transitionApp(f, vs, es, stt) {
  if (es) {
    return {
            TAG: /* Ev */1,
            _0: es.hd,
            _1: consCtx({
                  TAG: /* App2 */2,
                  _0: f,
                  _1: vs,
                  _2: undefined,
                  _3: es.tl
                }, stt)
          };
  } else {
    return doApp(f, vs, stt);
  }
}

function transitionCnd(ebs, ob, stt) {
  if (!ebs) {
    if (ob !== undefined) {
      return doBlk(ob, stt);
    } else {
      return $$continue(/* Uni */0, stt);
    }
  }
  var match = ebs.hd;
  return {
          TAG: /* Ev */1,
          _0: match[0],
          _1: consCtx({
                TAG: /* Cnd1 */3,
                _0: undefined,
                _1: match[1],
                _2: ebs.tl,
                _3: ob
              }, stt)
        };
}

function $$continue(v, stt) {
  var stk = caseCtx(stt);
  if (stk.TAG !== /* Yes */0) {
    return {
            TAG: /* Returning */3,
            _0: v,
            _1: stk._0
          };
  }
  var match = stk._0;
  var stt$1 = match[1];
  var ctxFrame = match[0];
  switch (ctxFrame.TAG | 0) {
    case /* Set1 */0 :
        return {
                TAG: /* Setting */2,
                _0: ctxFrame._0,
                _1: v,
                _2: stt$1
              };
    case /* App1 */1 :
        return transitionApp(v, /* [] */0, ctxFrame._1, stt$1);
    case /* App2 */2 :
        var vals_1 = ctxFrame._1;
        var vals = {
          hd: v,
          tl: vals_1
        };
        return transitionApp(ctxFrame._0, vals, ctxFrame._3, stt$1);
    case /* Cnd1 */3 :
        if (asLgc(v)) {
          return doBlk(ctxFrame._1, stt$1);
        } else {
          return transitionCnd(ctxFrame._2, ctxFrame._3, stt$1);
        }
    case /* BgnDef */4 :
        doSet(stt$1.env, ctxFrame._0, v);
        return transitionBgn(ctxFrame._2, stt$1);
    case /* BgnExp */5 :
        return transitionBgn(ctxFrame._1, stt$1);
    case /* PrgDef */6 :
        doSet(stt$1.env, ctxFrame._1, v);
        return transitionPrg(ctxFrame._0, ctxFrame._3, stt$1);
    case /* PrgExp */7 :
        print(v);
        return transitionPrg({
                    hd: v,
                    tl: ctxFrame._0
                  }, ctxFrame._2, stt$1);
    
  }
}

function doApp(v, vs, stt) {
  var p = asFun(v);
  if (p.TAG === /* Prm */0) {
    return $$continue(delta(p._0, vs), stt);
  }
  var b = p._1;
  var xs = p._0;
  if (xs.length === Js_list.length(vs)) {
    var env = extend(p._2, Js_array.concat(xs, xsOfBlock(b)));
    Js_array.forEachi((function (x, i) {
            doSet(env, x, Js_option.getExn(Js_list.nth(vs, i)));
          }), xs);
    return transitionBgn(b, pushStk(env, stt));
  }
  throw {
        RE_EXN_ID: ArityMismatch,
        _1: {
          TAG: /* Exactly */1,
          _0: xs.length
        },
        _2: Js_list.length(vs),
        Error: new Error()
      };
}

function $$return(v, stk) {
  if (stk) {
    var match = stk.hd;
    return $$continue(v, {
                ctx: match[0],
                env: match[1],
                stk: stk.tl
              });
  }
  throw {
        RE_EXN_ID: Impossible,
        _1: "Should have been handled by the top-level",
        Error: new Error()
      };
}

function setting(x, v, stt) {
  doSet(stt.env, x, v);
  return $$continue(/* Uni */0, stt);
}

var HasTerminated = /* @__PURE__ */Caml_exceptions.create("Main.HasTerminated");

function transition(state) {
  switch (state.TAG | 0) {
    case /* Tm */0 :
        throw {
              RE_EXN_ID: HasTerminated,
              Error: new Error()
            };
    case /* Ev */1 :
        var stt = state._1;
        var exp = state._0;
        switch (exp.TAG | 0) {
          case /* Con */0 :
              var val = {
                TAG: /* Con */0,
                _0: exp._0
              };
              return $$continue(val, stt);
          case /* Ref */1 :
              var val$1 = doRef(stt.env, exp._0);
              return $$continue(val$1, stt);
          case /* Set */2 :
              return {
                      TAG: /* Ev */1,
                      _0: exp._1,
                      _1: consCtx({
                            TAG: /* Set1 */0,
                            _0: exp._0,
                            _1: undefined
                          }, stt)
                    };
          case /* Lam */3 :
              var v = {
                TAG: /* Fun */1,
                _0: {
                  TAG: /* Cls */1,
                  _0: Js_list.toVector(exp._0),
                  _1: exp._1,
                  _2: stt.env
                }
              };
              return $$continue(v, stt);
          case /* App */4 :
              return {
                      TAG: /* Ev */1,
                      _0: exp._0,
                      _1: consCtx({
                            TAG: /* App1 */1,
                            _0: undefined,
                            _1: exp._1
                          }, stt)
                    };
          case /* Cnd */5 :
              return transitionCnd(exp._0, exp._1, stt);
          
        }
    case /* Setting */2 :
        return setting(state._0, state._1, state._2);
    case /* Returning */3 :
        return $$return(state._0, state._1);
    
  }
}

export {
  xsOfBlock ,
  stdout ,
  print ,
  extend ,
  UnboundIdentifier ,
  lookup ,
  UsedBeforeInitialization ,
  doRef ,
  doSet ,
  consCtx ,
  caseCtx ,
  evaluate ,
  ExpectButGiven ,
  asNum ,
  asLgc ,
  asFun ,
  doAdd ,
  transitionBgn ,
  transitionPrg ,
  pushStk ,
  doBlk ,
  deltaNum1 ,
  deltaNum2 ,
  deltaCmp ,
  arityOf ,
  ArityMismatch ,
  delta ,
  Impossible ,
  $$return ,
  setting ,
  $$continue ,
  transitionCnd ,
  doApp ,
  transitionApp ,
  HasTerminated ,
  transition ,
}
/* No side effect */
